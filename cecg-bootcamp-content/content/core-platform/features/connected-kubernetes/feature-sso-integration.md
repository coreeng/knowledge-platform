+++
title = "SSO Integration"
date = 2022-01-15T11:50:10+02:00
weight = 2
chapter = false
pre = "<b></b>"
+++

### Motivation

* Integrate with the organisation's SSO
* “Access control/Security/RBAC” department want any platform to integrate with standard ways of onboarding / offboarding engineers + have visibility of who has access to what.
* Users of the platform aka tenants don't need to learn a new way of authenticating
* Remove the burden on the platform engineering department of managing accounts and groups

### Requirements

* Integrate tenant authentication and authorisation with corporate single sign on
  * For both tenants and the platform team
* AD Group information available. This enables Corporate AD integration including delegation of group / team membership to the tenants rather than the platform team.


### Questions / Defuzz / Decisions

* What is the organisation's source of truth for users / groups?
  * Does it support OIDC?

### Additional Information

Depends on [Basic Clusters](/core-platform/features/connected-kubernetes/feature-basic-cluster/)

Most organisations will require integration with corporate SSO. A typical model will use Kubernetes’s OIDC support along with [Azure AD](https://medium.com/@olemarkus/using-azure-ad-to-authenticate-to-kubernetes-eb143d3cce10) (note this is applicable even if the core platform is in GCP/AWS).

This is a big [carrot](https://en.wikipedia.org/wiki/Carrot_and_stick) for security and access teams as it will enable existing group and user management processes to be followed e.g. when users leave a team / the company.

#### SSO on GKE with Azure AD

Authentication to the cluster via Azure AD is made possible by 3 main components:

* on the cluster, an identity service (anthos) which supports OIDC
* an Azure AD application
* on the client side, kubectl configured to generate a token

##### Anthos Identity Service

Anthos Identity Services (AIS) is used as the authentication proxy to the Identity Provider, Azure.

This is a service is not enabled by default on GKE.

It exposes an Envoy provy fronted by a Load Balancer that uses AIS to validate the ID token from the client. Once validated, the envoy proxy uses impersonation to make the request against the Kubernetes API.

AIS doesn't work with GKE autopilot as it cannot create certificate signing requests - see [GKE autopilot limitations (CSR)](https://cloud.google.com/kubernetes-engine/docs/concepts/autopilot-overview#certificate_signing_requests)

AIS uses a ClientConfig CRD in the `kube-public` namespace to configure how to validate the ID token against Azure. The ClientConfig is partially generated by the AIS operator - see [here](https://cloud.google.com/kubernetes-engine/docs/how-to/oidc#configuring_on_a_cluster) for more info on the fields.

{{< figure src="/images/reference/platform/anthos-sso.png" >}}

##### Azure Application

This app acts as an entry point to the Azure identity platform - see [Quickstart: Register an app in the Microsoft identity platform - Microsoft Entra](https://learn.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app#register-an-application)

It serves 2 purposes:
* it is used by the AIS service to validate the ID token
* it is used by kubectl to generate an ID token to access the cluster

Technically it could be split into 2 apps - one for each purpose.
However we found that this is unnecessary complicated especially given that the "client" app needs to be associated with the "server" app to ensure the "aud" claim in the generated token is the same as the server.

The app requires little configuration, it needs:

* to expose all group claims, so Azure groups can be used in Kubernetes RBAC
* to allow users to sign in
* a client secret to restrict who can request sign in
* an arbitrary return URL to allow kubectl to launch a browser window to delegate the authentication to Azure

##### kubectl token generation
Authenticating via Azure requires a specific .kube config that makes use of [kubelogin](https://github.com/int128/kubelogin) to obtain a token from Azure.

kubectl invokes kubelogin behind the scene to perform the authentication. It opens a browser window and let individuals log in to the provider unless they’re already logged in.

kubelogin gets an ID token that contains a groups claim that is used as part of the authorization process.

{{% notice info %}}
It's important to note that the .kube config must point to the Anthos identity endpoint (the envoy LB) and not the Kubernetes API server
{{% /notice %}}



